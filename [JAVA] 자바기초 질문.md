Q1. 자바의 특징   
Q2. 객체지향 언어의 장점과 정의   
Q3. 선호하는 IDE   
Q4. 클래스란   
Q5. 객체란    
Q6. 생성자란   
Q7. 지역변수, 인스턴스 변수   
Q8. 오버라이딩, 오버로딩의 차이   
Q9. Private, Public 접근 제어자의 차이   
Q10. 추상클래스, 인터페이스의 차이   
Q11. 배열과 리스트 (Array and List)   
Q12. 스트링, 스트링버퍼, 스트링 빌더 (String, StringBuffer and StringBuilder)   
Q13. 기본 접근제어자(Default)와 프로텍스(Protect) 접근 제어자   
Q14. 해쉬맵과 해쉬테이블   
Q15. 해쉬셋과 트리셋   
Q16. 자바 컬렉션   
Q17. 예외 (Exception)   
Q18. 예외의 종류   
Q19. 예외 처리 방법   
Q20. 파이널 키워드 (Final)   
    

    

Q1. JAVA의 특징   
- 자바는 객체 지향 프로그래밍 언어입니다.

- JVM 위에서 실행되기 때문에, 플랫폼에 의존하지 않고 실행이 가능합니다. 

- 고성능입니다(High Performance). 바이트코드로 변환되어 실행되기 때문입니다.

- 멀티 스레딩을 지원합니다.


Q2. 객체지향 언어의 장점과 특징을 정의하라   
장점: 1) 코드의 재사용성이 높다. : 라이브러리만 임포트하면 필요한 기능만 뽑아서 사용할 수 있으므로 생산성이 높아지고, 버그 발생률을 줄일 수 있다. 2) 객체 단위로 코드를 작성하므로 협업에 최적화되어있고 유지보수에 용이하다.

 

상속 (Inheritance) 

상속이란 어떤 클래스가 다른 클래스를 연장하여 다시 쓰는 것입니다. 기존 클래스는 부모 클래스가 되고, 새로 파생된 클래스는 서브클래스라고 부릅니다. 

캡슐화 (Encapsulation)

내부의 코드를 캡슐처럼 보호하기 위하여 사용됩니다. 즉 캡슐화를 위하여, 모든 인스턴스 변수를 private으로 명시하고, setter와 getter 메소드를 만들어 접근하게 합니다. 캡슐 안의 데이터에 직접적으로 접근하는 것은 불가능하며, 오로지 메소드로만 접근할 수 있습니다.

다형성 (Polymorphism)

하나의 객체를 여러가지 타입으로 해석할 수 있는 기술입니다. 다형성 구현을 위하여 메소드의 이름은 같게 하되, 리턴 형이나 혹은 파라미터의 개수나 타입을 다르게 하여 재정의할 수 있습니다.

추상 (Abstraction)

객체를 생성할 수 없는 클래스로, 오로지 부모클래스로써의 역할만 하는 클래스입니다. 클래스 앞에 abstract 키워드를 붙여서 생성합니다. 추상 클래스는 추상메소드를 반드시 가져야 하지만, 비추상메소드도 가질 수 있습니다. 추상 클래스가 가지는 추상메소드의 접근 제어자는 private은 올 수 없는데, 이는 생각해보면 당연한 것으로, 자식 클래스가 받아서 그 메소드를 오버라이드 할 수 있어야 하기 때문입니다.

인터페이스 (Interface)

인터페이스란 메소드 선언만 하고 구현은 되어있지 않은 템플릿입니다. 인터페이스는 다음의 조건들을 만족해야 합니다.

- 모든 메소드는 내부적으로 public abstract 이어야 하는데, 다른 클래스에서 구현하여 정의할 수 있어야 하기 때문입니다.
- 모든 변수는 public static final constant 여야 합니다.
- 인터페이스를 구현하는 클래스는 인터페이스에 선언된 모든 메소드를 포함하고 있어야 합니다.

자바는 다중 상속(2개의 클래스 이상 상속하지 못함)을 지원하지 않지만, 인터페이스를 통하여 보강할 수 있습니다. 인터페이스는 팀 작업 시에 공동 템플릿으로 이용 가능합니다.
참고*: Q10. 추상클래스, 인터페이스의 차이


Q3. 선호하는 JAVA 통합개발환경(IDE)은?   
가장 널리 알려진 IDE인 이클립스, 넷빈즈, 인텔리제이 중 개인의 선호도에 따라 답변.


Q4. 자바 클래스란 무엇인가?   
자바에서 모든 코드는 클래스 안에서 정의되며, 그 안에 변수와 메소드를 가집니다.


Q5. 객체(오브젝트)란 무엇인가?   
클래스의 인스턴스를 객체라고 합니다. 클래스는 코드를 모아서 정의한 것일 뿐으로, 특정 메모리를 할당받지 않지만, 객체는 JVM이 new()라는 키워드를 인식하여 인스턴스가 생성되는 그 순간, 특정 메모리를 할당받아 가지게 됩니다. 

Q6. 생성자(Constructor)란?   
생성자는 클래스와 같은 이름의 메소드로, 새 객체가 생성될 때 호출되는 메소드입니다. 명시적으로 생성자를 만들지 않아도 default로 만들어집니다. 생성자는 파라메터를 다르게 하여 오버로드 할 수 있으며, 파라메타 생성자를 만든다면 파라메터가 없는 default형 생성자도 명시적으로 만들어주어야 합니다.

 
Q7. 지역변수(Local Variable)와 인스턴스 변수가 각각 의미하는 것?   
지역변수는 메소드 안에서 정의되어, 메소드 안의 스코프 안에서만 존재합니다. 인스턴스 변수는 클래스에서 정의되어 클래스 전체의 스코프 안에서 존재하게 됩니다.

 
Q8. Overloading과 Overriding의 차이   
오버 로딩은, 다양한 타입과 개수의 파라메터를 가진 메소드를 여러 개 생성하여, 다양한 유형의 호출에 응답하게 하는 기술입니다.

 

오버 라이딩은, 상속 관계에 있는 두 클래스에서, 자식 클래스가 부모 클래스가 갖고 있지 않은 서브클래스만의 특정 정보를 재정의하게 하는 것입니다. 이 때 메소드 오버라이딩은 아래의 조건들을 만족하여야 합니다.

- 메소드 이름이 일치할 것

- 아규먼트가 같을 것

- 리턴 타입도 같을 것

 
Q9. Public 접근 제어자와 private 접근 제어자의 차이 (Access specifier)   
Public 멤버는 같은 패키지 안의 클래스뿐 아니라, 다른 패키지 안의 클래스에서도 보입니다.
Private 멤버는 오로지 그 클래스에서만 보입니다. 같은 패키지 안의 다른 클래스라 할지라도 보이지 않습니다



Q10. 추상 클래스와 인터페이스의 차이   
추상클래스	인터페이스
Default 생성자를 가진다 (서브클래스가 인스턴스화될 때 호출됨)	생성자를 가지지 않는다
추상 메소드, 비 추상 메소드를 포함할 수 있다	              추상 메소드만 선언할 수 있다
추상 클래스를 상속한 클래스는 꼭 모든 메소드를 구현할 필요는 없으며, 추상 메소드만 서브 클래스 안에서 구현되면 된다.

인터페이스를 구현하는 클래스는 인터페이스에서 선언된 모든 메소드를 다 구현해야 한다.

객체 생성 불가하므로 extend (상속)로 구현	객체 생성 불가하므로 implement 로 구현


Q11. Array와 List의 차이    
![image](https://user-images.githubusercontent.com/45925158/137085929-bec100bc-31e9-40cc-9b5c-10eb3207b489.png)


Q12. 스트링(String), 스트링버퍼(StringBuffer), 스트링빌더(StringBuilder)의 차이   

스트링은 값을 변화시킬 때, Heap에 새로운 메모리를 사용하고, 참조되는 메모리 주소만 바꿔주는 것이다
반면 스트링버퍼와 스트링빌더는 Stack에 값을 저장하므로 값이 변화할 때 값을 바꿔 쓴다.

2.1 스트링 버퍼는 Thread-safe이다. 즉 멀티스레드 환경에서 안전하다.   

2.2 스트링 빌더는 스트링 버퍼보다 빠르다.   

Q13. 기본 접근제어자(Default)와 프로텍스(Protect) 접근 제어자의 차이
 

클래스에서 접근 제어자를 지정하지 않고 메소드나 변수를 선언했을 때에는 접근 제어자가 기본적으로 Default 형이 된다. Default 멤버는 같은 패키지 안의 다른 패키지 클래스에서 볼 수 있지만, 해당 멤버 패키지 이외의 클래스에서는 볼 수 없다.

 

Protected는 Default와 동일하지만, Protected 클래스를 상속한 클래스는 패키지 밖에서도 볼 수 있다는 것이 차이점이다.

출처: https://gem1n1.tistory.com/27
